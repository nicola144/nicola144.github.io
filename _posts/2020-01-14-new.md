# Improved Auxiliary Particle Filters

In this post, my aim is to introduce a recent technique called IAPF (Improved Auxiliary Particle Filter). 
The ideal target reader has familiarity with Bayesian inference and basics of particle filters. However, the latter is much more optional, and if you are familiar with Bayesian inference in a "batch" setting (where data is processed all at once), you should be able to follow. If you are not, I will write a blogpost on Bayesian inference that assumes no prior background except basic rules of probability. Even then, I ambitiously hope that this post can be interesting to both Bayesian statistics experts who aren't aware of the work I will describe *and* people who see particle filters for the first time. It's possible, I just have to do it. 

1. [Preliminaries](#introduction)
2. [Particle Filters](#paragraph1)

## Brief introduction to sequential inference 

In Bayesian inference we want to update our beliefs on the state of some random variables, which could represent parameters of a parametric statistical model or represent some unobserved data generating process. Focussing on the "updating" perspective, the step to using Bayesian methods to represent dynamical systems is quite natural. The field of statistical signal processing has been using the rule of probabilities to model object tracking, navigation and even.. spread of infectious diseases. 
The probabilistic evolution of a dynamical system is often called a *state space model*. This is just an abstraction of how we think the state of the system evolves over time. Imagine we are tracking a robot's position (x,y coordinates) and bearing: these constitute a 3 element vector. At some specific timestep, we can have a belief, i.e. a probability distribution that represents how likely we think the robot is currently assuming a certain bearing etc. If we start with a prior, and define some likelihood function/ sampling process that we believe generates what we observe, we can update our belief over the system's state with the rules of probabilty.
Let the (uknown) state of the system at time <img src="https://rawgit.com/nicola144/nicola144/None/svgs/4f4f4e395762a3af4575de74c019ebb5.svg?invert_in_darkmode" align=middle width=5.936097749999991pt height=20.221802699999984pt/> be the vector valued random variable <img src="https://rawgit.com/nicola144/nicola144/None/svgs/b1ef56a4b1cccb8ad7d2aa5cf9440cc3.svg?invert_in_darkmode" align=middle width=12.422369849999988pt height=14.611878600000017pt/>.

We observe this state through a (noisy) measurement <img src="https://rawgit.com/nicola144/nicola144/None/svgs/b73bfbf97b4852a1593c7337b92ffe61.svg?invert_in_darkmode" align=middle width=14.942908199999989pt height=14.611878600000017pt/> (where v stands for visible). 

Now we have to start making more assumptions. What does our belief on <img src="https://rawgit.com/nicola144/nicola144/None/svgs/b1ef56a4b1cccb8ad7d2aa5cf9440cc3.svg?invert_in_darkmode" align=middle width=12.422369849999988pt height=14.611878600000017pt/> depend on ? 

Suprisingly to me, it turns out for **a lot** of applications it just needs to depend on the state at the previous timestep. 
In other words, we can say that <img src="https://rawgit.com/nicola144/nicola144/None/svgs/b1ef56a4b1cccb8ad7d2aa5cf9440cc3.svg?invert_in_darkmode" align=middle width=12.422369849999988pt height=14.611878600000017pt/> is sampled from some density <img src="https://rawgit.com/nicola144/nicola144/None/svgs/190083ef7a1625fbc75f243cffb9c96d.svg?invert_in_darkmode" align=middle width=9.81741584999999pt height=22.831056599999986pt/> conditional on <img src="https://rawgit.com/nicola144/nicola144/None/svgs/0d5c1e832a6ff7da96f0c991a6d7578a.svg?invert_in_darkmode" align=middle width=29.24893784999999pt height=14.611878600000017pt/>:

<p align="center"><img src="https://rawgit.com/nicola144/nicola144/None/svgs/dadc56d454c9d1d68b7ee4640769b0c6.svg?invert_in_darkmode" align=middle width=114.77823719999999pt height=16.438356pt/></p>

Further, usually the observation or visible is sampled according to the current state:

<p align="center"><img src="https://rawgit.com/nicola144/nicola144/None/svgs/4344f7520703c6b84f4c7d71ae195e55.svg?invert_in_darkmode" align=middle width=102.9927723pt height=16.438356pt/></p>

For example, a classic Gaussian likelihood for would imply that the belief over <img src="https://rawgit.com/nicola144/nicola144/None/svgs/b73bfbf97b4852a1593c7337b92ffe61.svg?invert_in_darkmode" align=middle width=14.942908199999989pt height=14.611878600000017pt/> is a linear combination of the current state's features. It is reasonable to assume this: if we take a measurement, we don't expect its outcome to be dependent on previous states of the system, just the current one. 

These collection of random variables and densities define the state space model completely. It is worth if you see this for the first time reflecting on the particular assumptions we are making. How the belief on <img src="https://rawgit.com/nicola144/nicola144/None/svgs/29be1e54112866e06f0c4d3e3d2cb2fd.svg?invert_in_darkmode" align=middle width=7.456577699999991pt height=14.611878600000017pt/> evolves with time could depend on many previous states; the measurement could depend on previous measurements if we had a sensor that degrades over time, etc. I am not great at giving practical examples, but if you are reading this, you should be able to see that this can be generalized in several ways. 
Note that a lot of the structure comes from assuming some variables are statistically independent from others. The field of probabilistic graphical models is dedicated to representing statistical independencies in the form of graphs (nodes and edges). One benefit of the graphical representation is that it makes immediately clear how more flexible we could be. 

In short, when the transition density and the observation densities are linear combination of their inputs with additive, i.i.d. Gaussian noise , then the state space model is often called Linear Dynamical System (LDS). When variables are discrete, it is often called Hidden Markov Model (HMM). These are just labels. 

There are several tasks that we can perform on the state space model described above. Each of these has a fancy name, but you should recall that technically all we are doing is applying the sum and product rule. These tasks are just associated to a *target* distribution which is the object of interest that we want to compute. 

**Filtering**: The target distributions are of the form: <img src="https://rawgit.com/nicola144/nicola144/None/svgs/10f2b7c6e5fc60f53884043018ebff31.svg?invert_in_darkmode" align=middle width=178.62053879999996pt height=24.65753399999998pt/>. This represents what we have learnt about the system's state at time <img src="https://rawgit.com/nicola144/nicola144/None/svgs/4f4f4e395762a3af4575de74c019ebb5.svg?invert_in_darkmode" align=middle width=5.936097749999991pt height=20.221802699999984pt/>, after observations up to <img src="https://rawgit.com/nicola144/nicola144/None/svgs/4f4f4e395762a3af4575de74c019ebb5.svg?invert_in_darkmode" align=middle width=5.936097749999991pt height=20.221802699999984pt/>.

**Smoothing**: The target distributions are of the form: <img src="https://rawgit.com/nicola144/nicola144/None/svgs/f72bb56ea1fb8fef28fc6733c3ac6084.svg?invert_in_darkmode" align=middle width=183.18844334999997pt height=24.65753399999998pt/>. This represent what we have learnt about the system's state after observing the *complete* sequence of measurements, and revised the previous beliefs obtained by filtering. 

**Parameter Estimation** The target distributions are of the form: <img src="https://rawgit.com/nicola144/nicola144/None/svgs/33385849fad9992c28635d097f696c23.svg?invert_in_darkmode" align=middle width=86.08036469999999pt height=24.65753399999998pt/>.  <img src="https://rawgit.com/nicola144/nicola144/None/svgs/a229f894fdd651a1cb705f641f154d84.svg?invert_in_darkmode" align=middle width=156.95589524999997pt height=26.48417309999999pt/>. In the case that the transition and/or observation densities are parametric and parameters are unknown, we can learn them from data by choosing those that both explain the observations well and agree with our prior beliefs. This task is sometimes referred to as *learning*, because parameters describe properties of sensors that can be estimated from data with machine learning methods. No, it is called learning just because it is cool. 




